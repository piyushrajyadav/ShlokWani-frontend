Sure Piyush! Here's the **complete Verilog code along with testbenches** for the following Xilinx ISE lab assignments (5 to 9):

---

## âœ… **5. Comparator, 2:4 Decoder, 3:8 Decoder**

### ğŸ”¹ (i) 4-bit Comparator

#### `comparator_4bit.v`
```verilog
module comparator_4bit(a, b, eq, gt, lt);
  input [3:0] a, b;
  output eq, gt, lt;

  assign eq = (a == b);
  assign gt = (a > b);
  assign lt = (a < b);
endmodule
```

#### `tb_comparator_4bit.v`
```verilog
module tb_comparator_4bit;
  reg [3:0] a, b;
  wire eq, gt, lt;

  comparator_4bit uut(a, b, eq, gt, lt);

  initial begin
    a = 4'b0000; b = 4'b0000;
    #10 a = 4'b1010; b = 4'b1001;
    #10 a = 4'b0011; b = 4'b0100;
    #10 a = 4'b1111; b = 4'b1111;
  end
endmodule
```

---

### ğŸ”¹ (ii) 2:4 Decoder

#### `decoder_2to4.v`
```verilog
module decoder_2to4(in, out);
  input [1:0] in;
  output [3:0] out;

  assign out = 1 << in;
endmodule
```

#### `tb_decoder_2to4.v`
```verilog
module tb_decoder_2to4;
  reg [1:0] in;
  wire [3:0] out;

  decoder_2to4 uut(in, out);

  initial begin
    in = 0; #10;
    in = 1; #10;
    in = 2; #10;
    in = 3; #10;
  end
endmodule
```

---

### ğŸ”¹ (iii) 3:8 Decoder

#### `decoder_3to8.v`
```verilog
module decoder_3to8(in, out);
  input [2:0] in;
  output [7:0] out;

  assign out = 1 << in;
endmodule
```

#### `tb_decoder_3to8.v`
```verilog
module tb_decoder_3to8;
  reg [2:0] in;
  wire [7:0] out;

  decoder_3to8 uut(in, out);

  initial begin
    in = 0; #10;
    in = 1; #10;
    in = 2; #10;
    in = 3; #10;
    in = 4; #10;
    in = 5; #10;
    in = 6; #10;
    in = 7; #10;
  end
endmodule
```

---

## âœ… **6. Decoders & Encoders (case, dataflow, loop)**

### ğŸ”¹ (i) 2:4 Decoder using `case`

```verilog
module decoder_2to4_case(in, out);
  input [1:0] in;
  output reg [3:0] out;

  always @(*) begin
    case (in)
      2'b00: out = 4'b0001;
      2'b01: out = 4'b0010;
      2'b10: out = 4'b0100;
      2'b11: out = 4'b1000;
    endcase
  end
endmodule
```

### ğŸ”¹ (ii) 4:2 Encoder (Dataflow)
```verilog
module encoder_4to2_df(in, out);
  input [3:0] in;
  output [1:0] out;

  assign out = (in[3]) ? 2'b11 :
               (in[2]) ? 2'b10 :
               (in[1]) ? 2'b01 : 2'b00;
endmodule
```

### ğŸ”¹ (iii) 4:2 Encoder using `case`
```verilog
module encoder_4to2_case(in, out);
  input [3:0] in;
  output reg [1:0] out;

  always @(*) begin
    case (in)
      4'b0001: out = 2'b00;
      4'b0010: out = 2'b01;
      4'b0100: out = 2'b10;
      4'b1000: out = 2'b11;
      default: out = 2'b00;
    endcase
  end
endmodule
```

### ğŸ”¹ (iv) 8:3 Encoder using Loop
```verilog
module encoder_8to3_loop(in, out);
  input [7:0] in;
  output reg [2:0] out;
  integer i;

  always @(*) begin
    out = 3'b000;
    for (i = 0; i < 8; i = i + 1)
      if (in[i]) out = i;
  end
endmodule
```

---

## âœ… **7. MUX/DEMUX using various styles**

### ğŸ”¹ (i) 2:1 MUX (Dataflow)
```verilog
module mux2to1_df(a, b, sel, out);
  input a, b, sel;
  output out;

  assign out = sel ? b : a;
endmodule
```

### ğŸ”¹ (ii) 4:1 MUX (Dataflow)
```verilog
module mux4to1_df(in, sel, out);
  input [3:0] in;
  input [1:0] sel;
  output out;

  assign out = in[sel];
endmodule
```

### ğŸ”¹ (iii) 4:1 MUX using `if-else`
```verilog
module mux4to1_if(in, sel, out);
  input [3:0] in;
  input [1:0] sel;
  output reg out;

  always @(*) begin
    if (sel == 2'b00) out = in[0];
    else if (sel == 2'b01) out = in[1];
    else if (sel == 2'b10) out = in[2];
    else out = in[3];
  end
endmodule
```

### ğŸ”¹ (iv) 4:1 MUX using `case`
```verilog
module mux4to1_case(in, sel, out);
  input [3:0] in;
  input [1:0] sel;
  output reg out;

  always @(*) begin
    case(sel)
      2'b00: out = in[0];
      2'b01: out = in[1];
      2'b10: out = in[2];
      2'b11: out = in[3];
    endcase
  end
endmodule
```

### ğŸ”¹ (v) 1:4 DEMUX using `case`
```verilog
module demux1to4_case(in, sel, out);
  input in;
  input [1:0] sel;
  output reg [3:0] out;

  always @(*) begin
    case(sel)
      2'b00: out = {3'b000, in};
      2'b01: out = {2'b00, in, 1'b0};
      2'b10: out = {1'b0, in, 2'b00};
      2'b11: out = {in, 3'b000};
    endcase
  end
endmodule
```

### ğŸ”¹ (vi) 1:4 DEMUX using Dataflow
```verilog
module demux1to4_df(in, sel, out);
  input in;
  input [1:0] sel;
  output [3:0] out;

  assign out = (sel == 2'b00) ? 4'b0001 :
               (sel == 2'b01) ? 4'b0010 :
               (sel == 2'b10) ? 4'b0100 :
                                4'b1000;
endmodule
```

---

## âœ… **8. Full Adder using Half Adders & 4-bit Adder (Structural)**

Already provided above! âœ…

---

## âœ… **9. MUX (Structural method)**

### ğŸ”¹ (i) 2:1 MUX using basic gates (Structural)

```verilog
module mux2to1_structural(a, b, sel, y);
  input a, b, sel;
  output y;

  wire nsel, and1, and2;

  not (nsel, sel);
  and (and1, a, nsel);
  and (and2, b, sel);
  or (y, and1, and2);
endmodule
```

### ğŸ”¹ (ii) 4:1 MUX using 2:1 MUX (Structural)

```verilog
module mux2to1(input a, input b, input sel, output y);
  assign y = sel ? b : a;
endmodule

module mux4to1_structural(input [3:0] in, input [1:0] sel, output y);
  wire w1, w2;

  mux2to1 m1(in[0], in[1], sel[0], w1);
  mux2to1 m2(in[2], in[3], sel[0], w2);
  mux2to1 m3(w1, w2, sel[1], y);
endmodule
```

---

Let me know if you'd like:

- Waveform simulation files (VCD)
- Help importing into **Xilinx ISE**
- PDF lab manual version
- Screenshots or diagrams for each circuit

Would you like me to package these in a zip or generate a GitHub-ready project structure?
